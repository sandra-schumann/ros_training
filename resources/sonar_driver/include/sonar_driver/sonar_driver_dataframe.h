#ifndef SONAR_DRIVER__SONAR_DRIVER_DATAFRAME_H
#define SONAR_DRIVER__SONAR_DRIVER_DATAFRAME_H

#include <string>

namespace sonar_driver
{
/**
 * @brief Datastructure that holds imu + sonar data
 * 
 */
struct Dataframe
{
  /**
   * @brief Default constructor
   * 
   */
  Dataframe()
  : imu_roll(0)
  , imu_pitch(0)
  , imu_yaw(0)
  , imu_accel_x(0)
  , imu_accel_y(0)
  , imu_accel_z(0)
  , imu_gyro_x(0)
  , imu_gyro_y(0)
  , imu_gyro_z(0)
  , range(0)
  {}

  /**
   * @brief CParametrized constructor
   * 
   * @param roll_in Unit: radians
   * @param pitch_in Unit: radians
   * @param yaw_in Unit: radians
   * @param accel_x Unit m/s2 
   * @param accel_y Unit m/s2 
   * @param accel_z Unit m/s2 
   * @param gyro_x Unit radians/s
   * @param gyro_y Unit radians/s
   * @param gyro_z Unit radians/s
   * @param range_in Unit m
   */
  Dataframe(float roll_in, float pitch_in, float yaw_in,
            float accel_x, float accel_y, float accel_z,
            float gyro_x, float gyro_y, float gyro_z,
            float range_in)
  : imu_roll(roll_in)
  , imu_pitch(pitch_in)
  , imu_yaw(yaw_in)
  , imu_accel_x(accel_x)
  , imu_accel_y(accel_y)
  , imu_accel_z(accel_z)
  , imu_gyro_x(gyro_x)
  , imu_gyro_y(gyro_y)
  , imu_gyro_z(gyro_z)
  , range(range_in)
  {}

  /**
   * @brief Overwrite the default copy-constructor because we don't want the potentially flawed compiler
   * autogenerated version of it. 
   * 
   * @param dataframe_in 
   */
  Dataframe(const Dataframe& dataframe_in)
  : imu_roll(dataframe_in.imu_roll)
  , imu_pitch(dataframe_in.imu_pitch)
  , imu_yaw(dataframe_in.imu_yaw)
  , imu_accel_x(dataframe_in.imu_accel_x)
  , imu_accel_y(dataframe_in.imu_accel_y)
  , imu_accel_z(dataframe_in.imu_accel_z)
  , imu_gyro_x(dataframe_in.imu_gyro_x)
  , imu_gyro_y(dataframe_in.imu_gyro_y)
  , imu_gyro_z(dataframe_in.imu_gyro_z)
  , range(dataframe_in.range)
  {}

  /**
   * @brief Define a compare equal operator
   * 
   * @param d2 
   * @return true 
   * @return false 
   */
  bool operator==(const Dataframe &d2) const
  {
    return (imu_roll == d2.imu_roll && 
            imu_pitch == d2.imu_pitch && 
            imu_yaw == d2.imu_yaw && 
            imu_accel_x == d2.imu_accel_x && 
            imu_accel_y == d2.imu_accel_y && 
            imu_accel_z == d2.imu_accel_z &&
            imu_gyro_x == d2.imu_gyro_x && 
            imu_gyro_y == d2.imu_gyro_y && 
            imu_gyro_z == d2.imu_gyro_z &&
            range == d2.range);
  }

  /**
   * @brief Define a compare not equal operator
   * 
   * @param d2 
   * @return true 
   * @return false 
   */
  bool operator!=(const Dataframe &d2) const
  {
    return !(*this == d2);
  }

  std::string print()
  {
    std::string out;
    out += std::to_string(imu_roll) + " ";
    out += std::to_string(imu_pitch) + " ";
    out += std::to_string(imu_yaw) + " ";
    out += std::to_string(imu_accel_x) + " ";
    out += std::to_string(imu_accel_y) + " ";
    out += std::to_string(imu_accel_z) + " ";
    out += std::to_string(imu_gyro_x) + " ";
    out += std::to_string(imu_gyro_y) + " ";
    out += std::to_string(imu_gyro_z);
    
    return out;
  }

  float imu_roll;  ///< Unit: radians
  float imu_pitch; ///< Unit: radians
  float imu_yaw;   ///< Unit:
  
  float imu_accel_x; ///< Unit: m/s2
  float imu_accel_y; ///< Unit: m/s2
  float imu_accel_z; ///< Unit: m/s2
  
  float imu_gyro_x; ///< Unit: radians/s
  float imu_gyro_y; ///< Unit: radians/s
  float imu_gyro_z; ///< Unit: radians/s
  
  float range; ///< Unit: meters
};
}

#endif